# Autogenerated wrapper script for ngraph_jll for x86_64-linux-gnu
export libcodegen, libcpu_backend, libdnnl, libeval_backend, libinterpreter_backend, libiomp5, libmklml_intel, libngraph, libnop_backend

using OpenSSL_jll
## Global variables
PATH = ""
LIBPATH = ""
LIBPATH_env = "LD_LIBRARY_PATH"
LIBPATH_default = ""

# Relative path to `libcodegen`
const libcodegen_splitpath = ["lib", "libcodegen.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcodegen_path = ""

# libcodegen-specific global declaration
# This will be filled out by __init__()
libcodegen_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libcodegen = "libcodegen.so"


# Relative path to `libcpu_backend`
const libcpu_backend_splitpath = ["lib", "libcpu_backend.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcpu_backend_path = ""

# libcpu_backend-specific global declaration
# This will be filled out by __init__()
libcpu_backend_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libcpu_backend = "libcpu_backend.so"


# Relative path to `libdnnl`
const libdnnl_splitpath = ["lib", "libdnnl.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libdnnl_path = ""

# libdnnl-specific global declaration
# This will be filled out by __init__()
libdnnl_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libdnnl = "libdnnl.so"


# Relative path to `libeval_backend`
const libeval_backend_splitpath = ["lib", "libeval_backend.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libeval_backend_path = ""

# libeval_backend-specific global declaration
# This will be filled out by __init__()
libeval_backend_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libeval_backend = "libeval_backend.so"


# Relative path to `libinterpreter_backend`
const libinterpreter_backend_splitpath = ["lib", "libinterpreter_backend.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libinterpreter_backend_path = ""

# libinterpreter_backend-specific global declaration
# This will be filled out by __init__()
libinterpreter_backend_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libinterpreter_backend = "libinterpreter_backend.so"


# Relative path to `libiomp5`
const libiomp5_splitpath = ["lib", "libiomp5.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libiomp5_path = ""

# libiomp5-specific global declaration
# This will be filled out by __init__()
libiomp5_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libiomp5 = "libiomp5.so"


# Relative path to `libmklml_intel`
const libmklml_intel_splitpath = ["lib", "libmklml_intel.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libmklml_intel_path = ""

# libmklml_intel-specific global declaration
# This will be filled out by __init__()
libmklml_intel_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libmklml_intel = "libmklml_intel.so"


# Relative path to `libngraph`
const libngraph_splitpath = ["lib", "libngraph.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libngraph_path = ""

# libngraph-specific global declaration
# This will be filled out by __init__()
libngraph_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libngraph = "libngraph.so"


# Relative path to `libnop_backend`
const libnop_backend_splitpath = ["lib", "libnop_backend.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnop_backend_path = ""

# libnop_backend-specific global declaration
# This will be filled out by __init__()
libnop_backend_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnop_backend = "libnop_backend.so"


"""
Open all libraries
"""
function __init__()
    global artifact_dir = abspath(artifact"ngraph")

    # Initialize PATH and LIBPATH environment variable listings
    global PATH_list, LIBPATH_list
    # From the list of our dependencies, generate a tuple of all the PATH and LIBPATH lists,
    # then append them to our own.
    foreach(p -> append!(PATH_list, p), (OpenSSL_jll.PATH_list,))
    foreach(p -> append!(LIBPATH_list, p), (OpenSSL_jll.LIBPATH_list,))

    global libcodegen_path = normpath(joinpath(artifact_dir, libcodegen_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libcodegen_handle = dlopen(libcodegen_path)
    push!(LIBPATH_list, dirname(libcodegen_path))

    global libcpu_backend_path = normpath(joinpath(artifact_dir, libcpu_backend_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libcpu_backend_handle = dlopen(libcpu_backend_path)
    push!(LIBPATH_list, dirname(libcpu_backend_path))

    global libdnnl_path = normpath(joinpath(artifact_dir, libdnnl_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libdnnl_handle = dlopen(libdnnl_path)
    push!(LIBPATH_list, dirname(libdnnl_path))

    global libeval_backend_path = normpath(joinpath(artifact_dir, libeval_backend_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libeval_backend_handle = dlopen(libeval_backend_path)
    push!(LIBPATH_list, dirname(libeval_backend_path))

    global libinterpreter_backend_path = normpath(joinpath(artifact_dir, libinterpreter_backend_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libinterpreter_backend_handle = dlopen(libinterpreter_backend_path)
    push!(LIBPATH_list, dirname(libinterpreter_backend_path))

    global libiomp5_path = normpath(joinpath(artifact_dir, libiomp5_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libiomp5_handle = dlopen(libiomp5_path)
    push!(LIBPATH_list, dirname(libiomp5_path))

    global libmklml_intel_path = normpath(joinpath(artifact_dir, libmklml_intel_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libmklml_intel_handle = dlopen(libmklml_intel_path)
    push!(LIBPATH_list, dirname(libmklml_intel_path))

    global libngraph_path = normpath(joinpath(artifact_dir, libngraph_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libngraph_handle = dlopen(libngraph_path)
    push!(LIBPATH_list, dirname(libngraph_path))

    global libnop_backend_path = normpath(joinpath(artifact_dir, libnop_backend_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnop_backend_handle = dlopen(libnop_backend_path)
    push!(LIBPATH_list, dirname(libnop_backend_path))

    # Filter out duplicate and empty entries in our PATH and LIBPATH entries
    filter!(!isempty, unique!(PATH_list))
    filter!(!isempty, unique!(LIBPATH_list))
    global PATH = join(PATH_list, ':')
    global LIBPATH = join(vcat(LIBPATH_list, [joinpath(Sys.BINDIR, Base.LIBDIR, "julia"), joinpath(Sys.BINDIR, Base.LIBDIR)]), ':')
end  # __init__()

